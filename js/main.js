// Generated by CoffeeScript 1.6.2
var Engine, Moving, Positioned, Renderable, Renderer, Resources, System, attachMover, average, sum, testEngine,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

sum = function(list) {
  return _.foldl(list, (function(s, x) {
    return s + x;
  }), 0);
};

average = function(list) {
  return sum(list) / list.length;
};

Resources = (function() {
  var callbacks, get, load, onReady, ready, resources;

  resources = {};
  callbacks = [];
  ready = function() {
    return _.all(_.values(resources));
  };
  load = function(url) {
    var img;

    if (resources[url]) {
      return resources[url];
    } else {
      img = new Image();
      img.onload = function() {
        var cb, _i, _len, _results;

        resources[url] = img;
        if (ready()) {
          _results = [];
          for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
            cb = callbacks[_i];
            _results.push(cb());
          }
          return _results;
        }
      };
      resources[url] = false;
      return img.src = url;
    }
  };
  get = function(url) {
    return resources[url];
  };
  onReady = function(callback) {
    callbacks.push(callback);
    if (ready() && !_.isEmpty(resources)) {
      return callback();
    }
  };
  return {
    load: load,
    get: get,
    onReady: onReady
  };
})();

Engine = (function() {
  var keyForComponent;

  keyForComponent = function(component) {
    return component.constructor.name.toLowerCase();
  };

  function Engine() {
    this.gameLoop = __bind(this.gameLoop, this);    this.entities = {};
    this.systems = [];
    this.lastEntityId = 0;
    this.running = false;
    this.lastFrameTime = null;
  }

  Engine.prototype.createEntity = function(components) {
    var c, componentsObject, entity, id, system, _i, _j, _len, _len1, _ref;

    componentsObject = {};
    for (_i = 0, _len = components.length; _i < _len; _i++) {
      c = components[_i];
      componentsObject[keyForComponent(c)] = c;
    }
    id = this.lastEntityId;
    this.entities[id] = componentsObject;
    _ref = this.systems;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      system = _ref[_j];
      system.updateCache(id, componentsObject);
    }
    this.lastEntityId += 1;
    return entity = {
      "id": id,
      "components": componentsObject
    };
  };

  Engine.prototype.updateEntity = function(id) {
    var components, system, _i, _len, _ref, _results;

    components = this.entities[id];
    _ref = this.systems;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      system = _ref[_i];
      _results.push(system.updateCache(id, components));
    }
    return _results;
  };

  Engine.prototype.addComponent = function(id, component) {
    var componentObject;

    componentObject = {};
    componentObject[keyForComponent(component)] = component;
    _.extend(this.entities[id], componentObject);
    return this.updateEntity(id);
  };

  Engine.prototype.addSystem = function(system) {
    this.systems.push(system);
    return system.buildCache(this.entities);
  };

  Engine.prototype.tick = function(dt) {
    var system, _i, _len, _ref, _results;

    _ref = this.systems;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      system = _ref[_i];
      _results.push(system.run(this.entities, dt));
    }
    return _results;
  };

  Engine.prototype.start = function() {
    this.running = true;
    this.lastFrameTime = null;
    return requestAnimationFrame(this.gameLoop);
  };

  Engine.prototype.gameLoop = function(paintTime) {
    var dt;

    if (this.lastFrameTime === null) {
      this.lastFrameTime = paintTime;
      return requestAnimationFrame(this.gameLoop);
    } else {
      dt = (paintTime - this.lastFrameTime) / 1000.0;
      this.lastFrameTime = paintTime;
      if (typeof this.beforeTick === "function") {
        this.beforeTick(dt);
      }
      this.tick(dt);
      if (typeof this.afterTick === "function") {
        this.afterTick(dt);
      }
      if (this.running) {
        return requestAnimationFrame(this.gameLoop);
      }
    }
  };

  return Engine;

})();

Positioned = (function() {
  function Positioned(pos) {
    this.pos = pos != null ? pos : [0, 0];
  }

  return Positioned;

})();

Renderable = (function() {
  function Renderable(url, pos, size) {
    this.url = url != null ? url : "resources/sun.gif";
    this.pos = pos != null ? pos : [0, 0];
    this.size = size != null ? size : [128, 128];
  }

  return Renderable;

})();

System = (function() {
  function System(satisfies, fn) {
    this.satisfies = satisfies;
    this.fn = fn;
    this.cache = {};
  }

  System.prototype.buildCache = function(entities) {
    var components, id, _results;

    _results = [];
    for (id in entities) {
      components = entities[id];
      if (this.satisfies(components)) {
        _results.push(this.cache[id] = true);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  System.prototype.updateCache = function(id, components) {
    if (this.satisfies(components)) {
      return this.cache[id] = true;
    } else {
      if (_.has(this.cache, id)) {
        return delete this.cache[id];
      }
    }
  };

  System.prototype.run = function(entities, dt) {
    var id, _i, _len, _ref, _results;

    _ref = _.keys(this.cache);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      if (_.has(entities, id)) {
        _results.push(this.fn(entities[id], dt));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  return System;

})();

Renderer = (function() {
  function Renderer(canvas) {
    var _this = this;

    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.system = new System(function(components) {
      return _.has(components, "renderable") && _.has(components, "positioned");
    }, function(components, dt) {
      var positioned, renderable;

      renderable = components != null ? components.renderable : void 0;
      positioned = components != null ? components.positioned : void 0;
      if (renderable && positioned) {
        return _this.ctx.drawImage(Resources.get(renderable.url), renderable.pos[0], renderable.pos[1], renderable.size[0], renderable.size[1], positioned.pos[0], positioned.pos[1], renderable.size[0], renderable.size[1]);
      }
    });
    this.clearCanvas = function(dt) {
      _this.ctx.fillStyle = "lightgrey";
      return _this.ctx.fillRect(0, 0, _this.canvas.width, _this.canvas.height);
    };
    this.drawFramerate = function(dt) {
      if (_this.showFramerate) {
        return _this.updateAndDrawFramerate(dt);
      }
    };
    this.framerates = [];
    this.showFramerate = true;
  }

  Renderer.prototype.toggleFramerate = function() {
    return this.showFramerate = !this.showFramerate;
  };

  Renderer.prototype.updateAndDrawFramerate = function(dt) {
    var drawFramerate,
      _this = this;

    drawFramerate = function() {
      _this.ctx.save();
      _this.ctx.fillStyle = "black";
      _this.ctx.font = "30px sans-serif";
      _this.ctx.fillText(average(_this.framerates).toFixed(1), 50, 50);
      return _this.ctx.restore();
    };
    this.framerates.push(1 / dt);
    while (this.framerates.length > 10) {
      this.framerates.shift();
    }
    return drawFramerate();
  };

  return Renderer;

})();

Moving = (function() {
  function Moving(velocity) {
    this.velocity = velocity != null ? velocity : [10, 10];
  }

  return Moving;

})();

attachMover = function(engine) {
  var mover;

  mover = new System(function(components) {
    return _.has(components, "positioned") && _.has(components, "moving");
  }, function(components, dt) {
    components.positioned.pos[0] += components.moving.velocity[0] * dt;
    return components.positioned.pos[1] += components.moving.velocity[1] * dt;
  });
  return engine.addSystem(mover);
};

testEngine = function(engine) {
  var e1, e2, e3;

  e1 = engine.createEntity([new Renderable(), new Positioned()]);
  e2 = engine.createEntity([new Renderable(), new Positioned([200, 200]), new Moving()]);
  e3 = engine.createEntity([new Renderable()]);
  engine.start();
  _.delay((function() {
    return engine.addComponent(e1.id, new Moving());
  }), 2000);
  return _.delay((function() {
    _.extend(e3.components, {
      "positioned": new Positioned()
    });
    return engine.updateEntity(e3.id);
  }), 4000);
};

/*
//@ sourceMappingURL=main.map
*/
